\chapter{Tiny86}\label{section:T86}
At the FIT CTU, in the NI-GEN course students have to write their own compiler.
To ease the code generation part, the Tiny86 (T86) architecture was created and
a virtual machine was written as a way to execute programs in that
architecture. The architecture was made as part of a masters
thesis~\cite{ivo2021tiny}. This chapter explores the T86 architecture and the
virtual machine that was made for it and delves into the existing debugging
capabilites of said virtual machine.

\section{The T86 Instruction Set Architecture}
The name is an abbreviation for Tiny x86, but in some aspects the architecture
is more similar to other architectures like ARM, for example it is a RISC
architecture. It is an educational ISA, so some properties are configurable,
like the number of available registers.

The T86 uses a harvard architecture, this means that the data and instructions
are separated from each other. The author doesn't specify the reason for this,
put presumably it is to ease the implementation of the virtual machine, since
the memory and instructions can be represented as two separate array-like
members of the virtual machine. Memory is addressable by 64-bit blocks, not
by 8-bit blocks as is custom in modern computers.

It shares some of the registers we saw on x86-64: the program counter (PC),
stack pointer (SP), base pointer (BP) and the flags register. The intended
roles for these registers are the same as on x86-64. It also has other general
purpose registers. The number of these is configurable. This is to ease the
initial code generation, the students can write a compiler that uses an
infinite amount of registers and worry about register allocation later. The
registers store a 64-bit value. It also has float registers, which can store
64-bit float values. These are separated from the normal registers, similarly
to x86-64.

The addressing modes, or what kind of operands instructions can have, include
immediate values, registers and memory accesses. They can also be combined in
in various way, like \texttt{[R0 + R1 * 2]}, or \texttt{[R0 + 10 + R1 * 2]}.
The addressing modes are however not arbitrary, \texttt{[R0 + R1 + R2]} is not
correct addressing mode for T86. For full list refer to \cite{ivo2021tiny}. The
instructions that are taken over from x64-64 have more restrictive addressing
modes. For example, the \verb|add| instruction can take a memory offset as an
destination operand in x64-86, but in T86 it can only take registers.

Other than that, the ISA is a subset of the x64-86 most used instructions, many
of which we have already seen in various examples spread thorough the thesis. A
small example of a piece of T86 program can be seen in figure
\ref{fig:t86-example}. Interesting exceptions to that are the IO instructions -
\texttt{PUTCHAR} and \texttt{GETCHAR}, which allow for very basic input and
output. Also, an \texttt{DBG} and \texttt{BREAK} are defined. These are used
for debugging, but in a very different way that we have seen in previous
sections. We will touch upon them when discussing the virtual machine
implementation, since they are very much tied to it.

\begin{figure}
    \begin{lstlisting}
SUB SP, 1
MOV R0, 5
MOV [BP - 2], R0
LEA R1, [BP - 2]
MOV [BP - 1], R1
MOV R2, 4
    \end{lstlisting}
    \caption{A small piece of a T86 program.}
    \label{fig:t86-example}
\end{figure}

\subsection{T86 Virtual machine}
The goal of the virtual machine was to simulate the execution as close as
possible to the real world CPUs. Speed of the execution was not a main focus.
For example, the CPU simulates the whole out-of-order execution briefly
described in section \ref{section:superscalar-cpu}. In fact, if the virtual
machine just interpreted the instructions one by one it would be significantly
faster. But the main point of the machine is for the students to learn of the
impact that pipelining, hazards and out of order execution has on the speed of
their programs. The virtual machine has statistics that can be exported to view
how much the generated program works with these properties that are present on
real world CPUs.

The virtual machine is implemented in C++, using the newer standards up to
C++17. The VM offers only a single interface, and that is the
\texttt{ProgramBuilder}. This is a class through which one may construct a
program for the T86 VM. An example of how to use this class is in figure
\ref{fig:t86-intro}. Currently, there is no other way for users to run programs
in the VM. This means that the students are tied to the C++ language, or use
some bindings if they want to use other language.

\begin{figure}
    \begin{minted}{cpp}
        ProgramBuilder pb;
        pb.add(MOV{Reg(0), 50);
        pb.add(PUTCHAR{Reg(0)});
        pb.add(HALT{});
        auto program = pb.program();
        Cpu cpu;
        cpu.start(std::move(program));
        while (!cpu.halted())
        cpu.tick();
    \end{minted}
    \caption{Simple example of how to create and run a simple program in the T86 VM.}
    \label{fig:t86-intro}
\end{figure}

\subsubsection*{Debug instructions}
The VM offers some limited debug capabilities. It has the \texttt{DBG} and
\texttt{BRK} instructions. The \texttt{DBG} instruction takes as an operand a
function. The function has the following signature: \texttt{void fun(Cpu\&)}.
This function then gets executed when the instruction is hit. This can prove
useful to inspect the internal state of the Cpu. In figure \ref{fig:t86-debug}
we show a possible usage of this instruction. The \texttt{BRK} instruction
works in a similar way. It however has no operand. Instead, a function must be
provided before execution to the CPU itself. \texttt{BRK} then always runs this
function when hit.

\begin{figure}
    \begin{minted}{cpp}
    pb.add(DBG{[](Cpu& cpu) {
        if (cpu.getRegister(Reg{0}) == 0) {
            std::cerr << "Register 0 is set to zero!\n";
        }
    });
    \end{minted}
    \caption{Example of an debug instruction in T86 VM.}
    \label{fig:t86-debug}
\end{figure}

Such debugging capabilites can be helpful. It however proves insufficient
when a step by step inspection is sought. To achieve this, a debug instruction
would have to placed at every second line of the program. Also, interactivity is
not much present. This function however can accept input, so one could create a
function robust enough to handle register and memory writing. An idea of how
this could be done is illustrated in \ref{fig:t86-pocket-debugger} via the
\texttt{BRK} instruction.
\begin{figure}
    \begin{minted}{cpp}
    cpu.connectBreakHandler([](Cpu& cpu) {
        char command;
        std::cin >> command;
        if (command == 'c') return; // continue
        else if (command == 'r') { // Read register
            int num;
            std::cin >> num;
            int regval = cpu.getRegister(num);
            std::cerr << std::format("Register {} = {}\n",
                                     num, regval);
        } else if (command == 'w') { // Write register
            int num;
            int val;
            std::cin >> num >> val;
            cpu.setRegister(Reg{num}, Reg{val});
        }
        ... // Other commands
    });
    \end{minted}
    \caption{Small debugger implementation using T86 BRK instruction, abbreviated.}
    \label{fig:t86-pocket-debugger}
\end{figure}
This however still does not come close to using a real debugger.
For example, setting something like a breakpoint is impossible since
the instruction vector is not writable.
