\chapter{Introduction}
Computers have many components that allow them to function. The most important
one is the central processing unit (CPU). This component does all the
calculations that the computer needs to do. However, the CPU can only
understand zeros and ones. Those sequences of zeroes and ones (called machine
code) make up a program that the CPU can execute. They can also save the
results of their calculations, for this, the computer has a memory, but writing
and reading from it can be slow. Fortunately, \textit{registers} come to the
rescue. They are part of the CPU itself and so it has very fast access to them,
but unfortunately, there are only a few of them.

Writing programs in machine code proved to be difficult. Even reading such
sequences and understanding their meaning is not easy for a human programmer.
Because of this, a text mapping was created, called \textit{assembly language}.
See the example in figure \ref{fig:assembly-example}, where we present a simple
assembly program. Each line contains an instruction or label. For example, the
\texttt{MOV EAX, 1} instruction moves value $1$ to the register named
\texttt{EAX}. Instructions are executed sequentially from top to bottom. But
certain instructions can change this flow of control. For example, the
instruction \texttt{JMP <dest>} jumps to a label and the execution continues
from there. This allows us to repeat or skip some part of the code. Assembly is
certainly more readable than binary but is still very close to the machine.

\begin{figure}\label{fig:assembly-example}
\begin{lstlisting}
PROC:
    PUSH    EBP
    MOV     EBP, ESP
    CMP     [EBP + 8], 0
    JLE     LN2
    MOV     EAX, 1
    JMP     LN1
LN2:
    XOR     EAX, EAX
LN1:
    POP     EBP
    RET
\end{lstlisting}
\caption{Example of assembly language}
\end{figure}

Finally, high level programming languages were created. The aim of these
languages is to abstract away the details of a computer. One of the older
languages is the C programming language (1972). An example of a program in C is
seen in figure \ref{fig:c-positive}, this program does the same thing as the
assembly one in figure
\ref{fig:assembly-example}.

\begin{figure}\label{fig:c-positive}
\begin{minted}{C}
int positive(int n) {
    if (n > 0) {
        return 1;
    } else {
        return 0;
    }
}
\end{minted}
\caption{C function that checks if a number is positive.}
\end{figure}

With C, knowing about the details of the CPU is no longer needed to write a
valid program. We do not store values in registers. Instead, they are kept in
variables. We can use conditional statements, which are more concise than using
jumps \cite{gotobad}. The functions and variables themselves also have names
from which can be apparent what is the purpose of it contrast to register names
like \texttt{EAX}.

However, upon deeper inspection of the language, it does not abstract away
everything. C has a feature called \textit{pointers}. Those are special kind of
variables that points into the computer memory\footnote{On modern OS, a concept
named \textit{virtual memory} is used. This maps the addresses used by the
process to physical memory. Pointer values are virtual memory addresses. See
\cite{modern-os}.}. So C does not necessarily abstract everything away. That
can sometimes be a good thing, because if you need to interact with the
computer hardware you don't have to resort to assembly, but can use C. For
example the Linux Kernel is written mostly in C \cite{linux-source}. Over the
years, many programming languages came to be, and some are more abstract than
others. For example, the Python language doesn't have pointers and in general,
is more abstract than C and easier to use.

However, we previously said that processors can only understand machine code
and high level languages are certainly not machine code. We need to translate
the language into assembly, and this is how \textit{compilers} came to be. A
compiler is a program that reads some source code of high level language and
produces assembly for the processor to understand. Compilers are a very
complicated piece of software, and we will talk about them in detail in chapter
\todo{Debugging - Compiler support}. For now, just keep in mind that the source
code needs to be someway translated into machine code and that the computer
cannot run the source code of high level language directly.

\begin{figure}[H]\label{fig:binary-search}
    \begin{minted}{c}
int binary_search(int* arr, int len, int n) {
    int lo = 0;
    int hi = len;
    while (lo < hi) {
        int i = (lo + hi)/2;
        if (arr[i] < n) {
            lo = i;
        } else if (arr[i] > n) {
            hi = i;
        } else {
            return 1;
        }
    }
    return 0;
}
    \end{minted}
    \caption{Binary search algorithm in C language.}
\end{figure}

In the \ref{fig:binary-search} figure we present a more complicated example of
a program written in high level programming language. This is an implementation
of the binary search algorithm. As an input, it receives sorted sequence of
numbers and some number $n$ and checks if that number $n$ is in the sequence.
This algorithm is widely used when searching because of its
$\mathcal{O}(\text{log}(n)$ complexity.

\section{Debugging}
Programs are mostly written by humans, and humans tend to make mistakes
\cite{human-error}. We are no exception, as we have also made a mistake in the
program that implements binary search. Let us try to run the program with a
\texttt{[1,2,3]} sequence and search for the number $4$. This number is
apparently not in the sequence, so the expected output would be $0$. Instead,
the program would run forever, because of a mistake we have made in the source
code. We will call such mistakes a \textit{bug}\footnote{The term \textit{bug}
actually comes from a real bug that got stuck in relays back when computers
were made from relays. They literally had to debug the machine by taking the
bug out.}.

Well, now we have to find out where the error is. We could just try to look at
the source code and find the mistake this way. This is a valid strategy, here
we could probably figure out that the condition \texttt{lo < hi} never comes to
be, since where else could we get stuck in an infinite loop? Now, it would be
helpful if we could see the states of \texttt{lo} and \texttt{hi} in each
iteration of the cycle. We could resort to print statements, but that is not
very flexible, we have to recompile the program and run it again just to see
different variable. It can also quickly get overwhelming, especially in an
infinite loop. All is not lost, a special piece of a program was created
specifically for this purpose, called a \textit{debugger}. Debugger is a
program that can inspect another program. They often have complete control of
the program. The program being debugged will be called a \textit{debuggee}.

Debugger is able to inspect the state of the debuggee, like the values of its
variables. Debugger is also able to control the flow of the program. They allow
\textit{breakpoints} to be set at each line of the source
code\footnote{Advanced debuggers allow breakpoints to be set inside
expressions. This is especially important for functional languages, as their
functions often consist of one big expression.}. When the program is about to
execute the line of code with the breakpoint, the control is passed back to the
debugger and the user can inspect the state of the program at that line. There
are also conditional breakpoints, which only trigger when some condition holds.
Example of such condition can be that the breakpoint gets activated only when
\texttt{i == 3}.

Finally, debuggers also allow \textit{stepping}. This also modifies the control
flow of the program.
\begin{itemize}
    \item \textit{step in} - Executes current statement and stops on the next
        one. If the current statement is a function call then it will be
        executed and the program will be paused on the first statement in that
        function.
    \item \textit{step over} - Same as a step in, but if the current statement
        is a function call then the program will be paused on the next
        statement after the call.
    \item \textit{step out} -  Executes as much as needed to return from the
        current function. Stops on the next statement that should be executed
        after the function returns.
\end{itemize}

Now, back to our program. Let us put a breakpoint on line $8$ after $i$ is set.
We will monitor how the \texttt{lo} and \texttt{hi} change. If you run the
program with the debugger attached, you will see an output similar to what is
displayed in figure \ref{fig:lldb-debug1}. Here, you can see the line on which
the execution was stopped. It is also possible to print the state of variables.
In each loop, you can print the value of a variable and then continue execution
until another breakpoint. There is only one set, so the execution will again be
stopped on line $8$. The value of \texttt{hi} will not change, which is
expected. Value of \texttt{lo} will gain following values: $0, 1, 2, 2, 2,
\dots$. The value apparently gets stuck at $2$ and never change. The value of
variable $i$ is computed as $i = (\text{lo} + \text{hi})/2 = (2 + 3)/2 = 2$,
because division in C rounds the value down. The fix is to change the line $9$
to \texttt{lo = i + 1}. With the debugger, it was simple to find out where the
error came from.

\begin{figure}\label{fig:lldb-debug1}
\begin{minted}{c}
   5   	    int hi = len;
   6   	    while (lo < hi) {
   7   	        int i = (lo + hi)/2;
-> 8   	        if (arr[i] < n) {
   9   	            lo = i;
   10  	        } else if (arr[i] > n) {
   11  	            hi = i;
Target 0: (a.out) stopped.
(lldb) p lo
(int) $0 = 0
(lldb) p hi
(int) $1 = 3
\end{minted}
\caption{Example of debugging a program in LLDB debugger.}
\end{figure}

We previously said that processors themselves only understand machine code. So
how it is possible that we can debug the program and the debugger knows about
lines, variables, etc. when the program itself is just machine code. The
compiler has to lend a hand here. It embeds information about the source code.
For example, it maps lines of source code to machine code instructions. Thanks
to this mapping, the debugger knows that line $x$ corresponds to instruction
$y$ in the machine code and can put a breakpoint there. If the compiler doesn't
emit any information into the executable the debugger would only work with
assembly, as seen in figure \ref{fig:lldb-debug2}. This is a lot more
discomforting than debugging source code directly.

\begin{figure}\label{fig:lldb-debug2}
\begin{lstlisting}
->  0x100003e3c <+112>: b      0x100003e78               ; <+172>
    0x100003e40 <+116>: ldr    x8, [sp, #0x20]
    0x100003e44 <+120>: ldrsw  x9, [sp, #0xc]
    0x100003e48 <+124>: ldr    w8, [x8, x9, lsl #2]
\end{lstlisting}
\caption{Example of debugging a program in LLDB debugger without debugging information.}
\end{figure}

\section{Teaching compilers}
Many schools about computer science have a compiler course. And Faculty of
Information Technologies is no exception. The course there is called
\textit{Code Generators} (NI-GEN). In this course, students are tasked to build
a simple compiler for a C-like language. The target of the compiler is Tiny86
(T86) architecture. This architecture \todo{Never mentioned any architectures
before} does not have a a processor that implements it, instead a virtual
machine, a program that reads the assembly and executes it, was created for it.
The architecture is supposed to ease the code generation and let the students
focus on the more interesting parts of the compiler, like register allocation
or optimization, instead of the nitty gritty detail of x86 (or different
architecture, should the students choose it).

There is however a problem with using T86, there is no debugger that supports
it. So if a compiler of some student generates code badly, it takes a
non-trivial amount of effort to find the error. T86 offers some very light
debugging capabilities, but they are very far from real debugging. Also,
compiling debugging information is not taught at all in the NI-GEN course
because there is no reason to as of now. If a debugger was provided to the
students, it might be incentivizing to compile such information to ease their
lives later, when they will need to find errors in their compilers which will
inevitably happen. This way they will also learn how and what information the
compiler needs to embed for the debugger to work.

\section{Goals of the thesis}
The primary goal is to create a debugger for the T86 virtual machine which
allows debugging both on the machine code level and at the source code level.
The debugger should be extensible enough to work with intermediate
representation also. The debugger should be similar to real-world debuggers, in
terms of how it works. This will require non-trivial changes in the T86 virtual
machine source code. The students' compilers will also have to generate
debugging information. The format of the debugging information should be so
that it is not discouraging for students to generate.

\section{Structure of the thesis}
\begin{enumerate}
    \item The \textit{Introduction} describes the motivation behind the thesis
        and basic terms with which should the reader be familiar.
    \item \textit{Debugging support} describes how are debuggers implemented
        and what support is provided on various levels (OS, processors,
        compilers) for them to work.
    \item \textit{T86 Virtual Machine} describes the T86 architecture and how
        are some of the parts implemented.
    \item \textit{Implementation} describes how the implementation is done. It
        is divided into three main parts, first is what changes and additions
        were necessary to the T86 VM. Then it is described how the debugger
        itself is implemented. Finally, a proof of concept compiler is created
        to demonstrate how the debugger works and that it is indeed simple to
        generate debugging information for it.
    \item \textit{Conclusions} summarizes the result of the thesis and speaks
        of possible future work.
\end{enumerate}

