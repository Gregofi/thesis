\chapter{Introduction}
At the core of every computer program lies the Central Processing Unit (CPU),
which is responsible for executing programs. The CPU excels at performing very
primitive operations very fast. These operations are called instructions, they
can perform simple arithmetics, move values from and to memory, and change the
control flow of the program. The instructions are encoded as a sequences of
binary numbers which are easy for the CPU to understand, but for humans they
are rather incomprehensible.

To help programmers better understand written programs, a text mapping was
created, called \textit{assembly language}. Each instruction is now assigned an
text representation, as are the operands of the instruction. The control flow
instructions now doesn't have to jump to address offset, but can instead use
labels. Example of a simple program in assembly language can be seen in figure
\ref{fig:simple-assembly}. If a programmer knows the instruction set
architecture of the processor he can easily recognize the instructions the
program is made of.

\begin{figure}
    \begin{lstlisting}
    proc:
        push    ebp
        mov     ebp, esp
        cmp     [ebp + 8], 0
        jle     ln2
        mov     eax, 1
        jmp     ln1
    ln2:
        xor     eax, eax
    ln1:
        pop     ebp
        ret
    \end{lstlisting}
    \caption{Example of assembly language}
    \label{fig:simple-assembly}
\end{figure}

But, as the computers became increasingly more powerful, so did the programs
became bigger and more complex. When programming in the assembly language,
the programmer must have an extensive knowledge of the processor's internal
workings instead of focusing at the task at hand.

To spare the programmers those issues, high level programming languages were
created. These are designed to abstract from the specific machine the program
will run on, allowing programmers to focus more on their task. As shown in
figure \ref{fig:c-positive}, even a simple program written in the C programming
language, one of the oldest programming language around, provides a clear
understanding of the functionality. In contrast, examining the equivalent
program in assembly language, as seen in figure \ref{fig:simple-assembly},
requires knowledge of the specific architecture of the machine.

\begin{figure}\label{fig:c-positive}
\begin{minted}{c}
bool positive(int n) {
    if (n > 0) {
        return true;
    } else {
        return false;
    }
}
\end{minted}
\caption{C function that checks if a number is positive.}
\end{figure}

However, we previously said that processors can only understand machine code
and high level languages are far from it. Therefore, a translation of the
high-level language into machine code is necessary, this is a task for a
\texttt{compiler}. A compiler is a program that reads some source code of
high-level language and produces machine code. Compilers are a very complicated
piece of software, and we will talk about them in detail in chapter
\ref{section:source-level-debugging}. For now, it is important to uderstand
that the computer cannot run the source code of a high-level language directly,
and consequently it must be translated into machine code. Additionaly,
compilers often take advantage of special features of the architecture to make
the programs faster.

\begin{figure}[H]\label{fig:binary-search}
    \begin{minted}{c}
int binary_search(int* arr, int len, int n) {
    int lo = 0;
    int hi = len;
    while (lo < hi) {
        int i = (lo + hi)/2;
        if (arr[i] < n) {
            lo = i;
        } else if (arr[i] > n) {
            hi = i;
        } else {
            return 1;
        }
    }
    return 0;
}
    \end{minted}
    \caption{Binary search algorithm in C language.}
\end{figure}

In the \ref{fig:binary-search} figure we present a more complicated example of
a program written in high level programming language. This is an implementation
of the binary search algorithm. As an input, it receives sorted sequence of
numbers and some number $n$ and checks if that number $n$ is in the sequence.
This algorithm is widely used when searching because of its
$\mathcal{O}(\text{log} n)$ complexity.

\section{Debugging}
Programs are mostly written by humans, and humans tend to make
mistakes~\cite{human-error}. We are no exception, as we have also made a
mistake in the program that implements binary search. Let us try to run the
program with a \texttt{[1,2,3]} sequence and search for the number $4$. This
number is apparently not in the sequence, so the expected output would be $0$.
Instead, if we run the program it would run forever, because of a mistake we
have made in the source code. We will call such mistakes a
\textit{bug}\footnote{The term \textit{bug} actually comes from a real bug that
got stuck in relays back when computers were made from relays. They literally
had to debug the machine by taking the bug out.}.

We of course have to fix this bug, otherwise no one would use our programs if
they didn't work. We could just try to look at the source code and find the
mistake this way. This is a valid strategy, here we could probably figure out
that the condition \texttt{lo < hi} never comes to be, since where else could
we get stuck in an infinite loop? Now, it would be helpful if we could see the
states of \texttt{lo} and \texttt{hi} in each iteration of the cycle. We could
resort to print statements, but that is not very flexible, we have to recompile
the program and run it again just to see different variable. It can also
quickly get overwhelming, especially in an infinite loop. All is not lost
however, as a special program was created specifically to inspect running
programs, called a \textit{debugger}. The program being debugged will be called
a \textit{debuggee}.

Debugger is able to inspect the state of the debuggee, like the values of its
variables. It is also able to control the flow of the program. They allow
\textit{breakpoints} to be set at each line of the source
code\footnote{Advanced debuggers allow breakpoints to be set inside
expressions. This is especially important for functional languages, as their
functions often consist of one big expression.}. When the program is about to
execute the line of code with the breakpoint, the control is passed back to the
debugger and the user can inspect the state of the program at that line. There
are also conditional breakpoints, which only trigger when some condition holds.
Example of such condition can be that the breakpoint gets activated only when
\texttt{i == 3}.

Finally, debuggers also allow \textit{stepping}. This also modifies the control
flow of the program.
\begin{itemize}
    \item \textit{step in} - Executes current statement and stops on the next
        one. If the current statement is a function call then it will be
        executed and the program will be paused on the first statement in that
        function.
    \item \textit{step over} - Same as a step in, but if the current statement
        is a function call then the program will be paused on the next
        statement after the call.
    \item \textit{step out} -  Executes as much as needed to return from the
        current function. Stops on the next statement that should be executed
        after the function returns.
\end{itemize}

Now, back to our program. Let us put a breakpoint on line $8$ after $i$ is set.
We will monitor how the \texttt{lo} and \texttt{hi} change. If you run the
program with the debugger attached, you will see an output similar to what is
displayed in figure \ref{fig:lldb-debug1}. Here, you can see the line on which
the execution was stopped. It is also possible to print the state of variables.
In each loop, you can print the value of a variable and then continue execution
until another breakpoint. There is only one set, so the execution will again be
stopped on line $8$. The value of \texttt{hi} will not change, which is
expected. Value of \texttt{lo} will gain following values: $0, 1, 2, 2, 2,
\dots$. The value apparently gets stuck at $2$ and never change. The value of
variable $i$ is computed as $i = (\text{lo} + \text{hi})/2 = (2 + 3)/2 = 2$,
because division in C rounds the value down. The fix is to change the line $9$
to \texttt{lo = i + 1}. With the debugger, it was simple to find out where the
error came from and we didn't have to recompile the program.

\begin{figure}\label{fig:lldb-debug1}
\begin{minted}{c}
   5   	    int hi = len;
   6   	    while (lo < hi) {
   7   	        int i = (lo + hi)/2;
-> 8   	        if (arr[i] < n) {
   9   	            lo = i;
   10  	        } else if (arr[i] > n) {
   11  	            hi = i;
Target 0: (a.out) stopped.
> p lo
(int) $0 = 0
> p hi
(int) $1 = 3
\end{minted}
\caption{Example of debugging a program in LLDB debugger.}
\end{figure}

We previously said that processors themselves only understand machine code. So
how it is possible that we can debug the program and the debugger knows about
lines, variables, etc. when the program itself is just machine code. The
compiler has to lend a hand here. It embeds information about the source code.
For example, it maps lines of source code to machine code instructions. Thanks
to this mapping, the debugger knows that line $x$ corresponds to instruction
$y$ in the machine code and can put a breakpoint there. If the compiler doesn't
emit any information into the executable the debugger would only work with
assembly, as seen in figure \ref{fig:lldb-debug2}. This is a lot more
discomforting than debugging source code directly.

\begin{figure}\label{fig:lldb-debug2}
\begin{lstlisting}
->  0x100003e3c <+112>: b      0x100003e78               ; <+172>
    0x100003e40 <+116>: ldr    x8, [sp, #0x20]
    0x100003e44 <+120>: ldrsw  x9, [sp, #0xc]
    0x100003e48 <+124>: ldr    w8, [x8, x9, lsl #2]
\end{lstlisting}
\caption{Example of debugging a program in LLDB debugger without debugging information.}
\end{figure}

\section{Teaching compilers}
Many schools about computer science have a compiler course, and Faculty of
Information Technologies is no exception. The course there is called
\textit{Code Generators} (NI-GEN). In this course, students are tasked to build
a simple compiler for a C-like language. The target of the compiler is Tiny86
(T86) architecture. This architecture \todo{Never mentioned any architectures
before} does not have a a processor that implements it, instead a virtual
machine, a program that reads the assembly and executes it, was created for it.
The architecture is supposed to ease the code generation and let the students
focus on the more interesting parts of the compiler, like register allocation
or optimization, instead of the nitty gritty detail of real CPUs architectures.

There is however a problem with using T86, there is no debugger that supports
it. So if a compiler of some student generates wrong code, which is frankly
inevitable, it takes a non-trivial amount of effort to find the error. T86
offers some very light debugging capabilities, but they are very far from real
debugging. Also, compiling debugging information is not taught at all in the
NI-GEN course because there is no reason to as of now. If a debugger was
provided to the students, it might be incentivizing to compile such information
to ease their lives later, when they will need to find errors in their
compilers. This way they will also learn how and what information the compiler
needs to embed for the debugger to work.

\section{Goals of the thesis}
The primary goal is to create a debugger for the T86 virtual machine which
allows debugging both on the machine code level and at the source code level.
The debugger should be extensible enough to work with intermediate
representation also. The debugger should be similar to real-world debuggers, in
terms of how it works. This will require non-trivial changes in the T86 virtual
machine source code. The students' compilers will also have to generate
debugging information. The format of the debugging information should be so
that it is not discouraging for students to generate but also comparable
to debugging information generated by real compilers.

\section{Structure of the thesis}
\begin{enumerate}
    \item The \textit{Introduction} describes the motivation behind the thesis
        and basic terms with which should the reader be familiar.
    \item \textit{Debugging support} describes how are debuggers implemented
        and what support is provided on various levels (OS, processors,
        compilers) for them to work.
    \item \textit{T86 Virtual Machine} describes the T86 architecture and how
        are some of the parts implemented.
    \item \textit{Implementation} describes how the implementation is done. It
        is divided into three main parts, first is what changes and additions
        were necessary to the T86 VM. Then it is described how the debugger
        itself is implemented. Finally, a proof of concept compiler is created
        to demonstrate how the debugger works and that it is indeed simple to
        generate debugging information for it.
    \item \textit{Conclusions} summarizes the result of the thesis and speaks
        of possible future work.
\end{enumerate}
