\chapter{Introduction}
Todays world is practically run by a computers. They are everywhere, from our wrists to our cars.
All of these computers car run some sort of programs. These programs define what the computer does.
Programs are executed by a processor, an integral part of every computer. Processors have several instructions,
which can be executed, and can also read and write to either memory or registers. However, processors can only
understand machine code. For example, very simple machine code instruction is \mintinline{0100 0001} (in x86 architecture).
This instruction increases the value which is in register ECX by one. Real programs are made of thousands and thousands of
such instructions. Making sense of these programs for human is very, very difficult. To read a program a programmer would
have to have a mapping from machine code to instruction in his head at least for the most used instructions. Even if the
programmer knew such mappings, sequences of binary would be very hard to read. 

\section{Assembly language}
Assembly language is almost a direct mapping from instruction and operand names to machine code. For example the code \mintinline{INC ECX}
is the previously mentioned increment by one instruction. This is way more readable for programmer than \mintinline{0100 0001}.
Understanding instructions by themselves is simpler. But programs are still difficult to read. Consider following example:
\begin{lstlisting}
PROC:
    PUSH    EBP
    MOV     EBP, ESP
    CMP     [EBP + 8], 0
    JLE     LN2            ; Jump if the EPC + 8 value is smaller than 0
    MOV     EAX, 1
    JMP     LN1
LN2:
    XOR     EAX, EAX
LN1:
    POP     EBP
    RET
\end{lstlisting}
This code checks if value which is in memory at offset \mintinline{[EBP + 8]} is positive and stores $1$ to register \mintinline{EAX} if it is positive, or zero
if it is not positive. Understanding the instructions one by one is doable. But understanding what this program does as a whole is not apparent at first glance. 

Programs are executed from top to bottom, instruction by instruction. But certain instructions can change this control flow. For example the instruction \mintinline{JMP dest}
jumps to a label (\mintinline{LN1} in the example) and the execution continues from there. This allows the program to repeat or skip some part of the code.
Notice the JLE instruction. This instruction performs mentioned jump but only if certain other condition holds true.
These instructions can make it harder for programmer to follow the control flow \todo{GOTO statements considered harmful}.
Programs can also contain comments, as is apparent in the example. These bits only serve to make the code easier to understand.
They are left out when the translation to machine code is done.

Assembly programming is still very close to the underlying machine. To program in assembly, you still need to know
how computers work. If you want to create program for different architectures, you need to write it for each of them
separately because different architectures might use different instructions, have different registers or be completely 
different (for example stack based).

\section{High level programming languages}
Aim of these languages is to abstract away the details of the computer. One of the older languages is the C programming language (1972).
Example of a program in C:
\begin{minted}{C}
int positive(int n) {
    if (n > 0) {
        return 1;
    } else {
        return 0;
    }
}
\end{minted}
This is the same program as the assembly one. Knowing about internals of the computer is no longer needed.
We do not store values into registers, instead they are kept in variables. We can use conditional statements,
which are more concise then using jumps. The functions and variables themselves also have names from which
can be apparent what is the purpose of it (contrast to register named EAX).

However, upon deeper inspection of the language, it does not abstract away everything. C has a feature called
\textit{pointers}. Those are special kind of variables which points into the computer memory\footnote{On modern OS,
a concept named virtual memory is used. This maps addresses used by process to physical memory. Pointer values are virtual memory addresses. See \cite{modern-os}.}.
So C does not necessarily abstract everything away. That can sometimes be a good thing, because if you need to 
interact with the computer hardware you don't have to resort to assembly, but can use C. For example the Linux
operating system Kernel is written in C.

Not everyone needs that sort of intimacy with the hardware. So more and more abstract languages were created.
Here is a program that takes two sequences of ordered numbers and merges these two together so that the result
is still sorted sequence of numbers. It is written in three different languages to illustrate how can they differ.
\begin{minted}{c}
int* merge (int *src1, size_t len1, int *src2, size_t len2) {
    int *dest = malloc((len1 + len2) * sizeof(*dest));
    size_t i = 0;
    while (src1 != src1 + len1 && src2 != src2 + len2)
        dest[i++] = src1 <= src2 ? *(src1++) : *(src2++);
    while (src1 != src1 + len1)
        dest[i++] = *(src1++);
    while (src2 != src2 + len2)
        dest[i++] = *(src2++);
    return dest;
}
\end{minted}
Here, the array where we will store the result is dynamically allocated using
the \textit{malloc} functions. This function takes how many bytes it should
allocate as an argument and returns continuous memory of that size. The two
sequences to be merged are pointed at by variables. Since pointers are just
memory addresses, we need to know how long the sequences are and pass that
along with the pointers.

\begin{minted}{python}
def merge(l1, l2):
    result = []
    idx1, idx2 = 0, 0
    while idx1 < len(l1) and idx2 < len(l2):
        result.append(l1[idx1] if l1[idx1] < l2[idx2] else l2[idx2])
    result.extend(l1[idx1:])
    result.extend(l2[idx2:])
    return result
\end{minted}

Python goes further. The code is similar but the length of the sequence (python calls it a \textit{list})
is baked into the sequence itself. Also, we do not have to say how long will the list be,
Python manages everything for us. In C, we had to have a while cycle that appended
the rest of the sequence to the output. In python, lists (and other objects) have methods,
like the \textit{extend}. Notice how we had to specify what type the variables are in C.
This is not needed in Python, since the language is dynamically typed, whereas 
C is statically typed. This has its own pros and cons, which is briefly discussed in \todo{Compilling} chapter.

Python and C are so called imperative languages. These languages are 
made of statements which are executed one by one (similarly to assembly language).
The languages are similar in terms how an algorithm will be written in either of them.
However, there are also other paradigms of programming, like object oriented or functional programming.

\begin{minted}{haskell}
merge :: Ord a => [a] -> [a] -> [a]
merge [] a = a
merge a [] = a
merge (h1:t1) (h2:t2) | h1 < h2 = h1:merge t1 (h2:t2)
                      | otherwise = h2:merge (h1:t1) t2
\end{minted}
Haskell is a functional programming language. As is apparent, functional programming is very different from imperative,
altrough the two words sometimes intertwine, for example through higher order functions. In the rest of this thesis, we will
mainly talk about imperative languages, but will sometimes mention how things differ for functional languages.

\section{Debugging}
Even though the languages keep getting better and better.

\section{Compilers}

