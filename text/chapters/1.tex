\chapter{Debugging}
Often times, it happens that a written program has different behaviour than we expected. This can manifest in all sorts of ways, from different output to crashing. There are many ways of finding the mistake, one of them is using a debugger to debug the program \cite{software-debugging-testing-verification}.
Debuggers can attach to existing process or spawn a new one. They often have functionalities like displaying variable/register values, allowing to read and write into program memory, change the executed code itself and to stop at some point in the program. Implementation of debuggers can vary based on target machine, operating system or if the program is native or expected to be run by an interpreter.

There are multiple debugger types \todo{Ocitovat Kokesovo prednasky}.
\begin{itemize}
    \item An user-mode debugger - Can debug applications in user mode.
    \item A kernel debugger - Can debug the kernel and the kernel drivers.
    \item A source-level debugger - Can set breakpoints in application according to its source code.
    \item An assembly-level debugger - Works with the assembly language
\end{itemize}

This thesis will mainly focus on source-level debugging and assembly level debugging. We will see that those two are closely intertwined. First of, a brief overview of source-level and assembly-level debugger features will follow.

\section{Breakpoint}\label{breakpoint}
Breakpoints are one of the most important debugger features. Source-level debugger can set them on some location in the source code and when the program arrives at that location, it will pause. The debugger can then inspect various traits of the running program. The location is most often line, but can even be inside expressions\footnote{This is especially important for functional languages, where function can just be one big expression.}. Hovewer we will consider breakpoints that only stops on a line. Assembly-level debuggers can stop when instruction on some address is being executed, so effectively on a line of the assembly program.

Breakpoints may also have conditions which are checked when the program arrives at given line. If the condition holds then the program is paused. This can be useful for example to stop at the end of the loop.

\section{Stepping}
Debuggers also allows to "make a step" in the code. It executes one line and pauses on the next one. This means that we can run the program line by line and inspect the behaviour of the program.
There are often multiple categories of steps:

\begin{itemize}
    \item Step in - Executes one line. If the line was call to function, it pauses on the first line of the called function.
    \item Step over - Executes one line. If the line was call to function, it executes the whole body of the function and pauses on the line after the call instruction.
    \item Step out - Runs the program until it returns from current function, and pauses on that line.
\end{itemize}

\section{Debugging native programs}
For now, we pretended that source-level debuggers can magicaly work with lines of source code. However, for programs to be run they first need to be compiled to native code - series of binary instructions (there are also interpreted programs, which we will touch upon later). Debugger then interacts with this native code. It, by itself, has no idea that line $x$ correspond to address $y$. The compiler must embed this information in the executable, or somewhere else, for the debugger to know this type of information. One of such standards of encoding debug informating is DWARF format \cite{dwarf}, it will be thoroughly described in \todo{TODO} section.  

As we mentioned, there are some debuggers which only works on the assembly level. They do not perform any mapping to the source code. And the debuggers that do have to work with machine code all the same. In the next section we will explore how assembly-level debuggers are implemented. Implementation itself can greatly differ based on operating system or target machine. Following sections aims to describe the most often used OS and targets.

\subsection{Breakpoints}
Term \textit{debuggee} means a program that is being debugged. The instuction architecture \textit{x86} contains special instruction \lstinline{INT3}, opcode \lstinline{0xCC}. When processor executes this instruction it issues special interrupt and advances program counter by one. The interrupt is then handled by OS. How the handling is done depends heavily on OS and will be covered later. 

Consider following code
\begin{lstlisting}
0x0 xor    eax,eax        33 c0
0x2 mov    esp,ebp        8b e5
0x4 pop    ebp            5d
\end{lstlisting}

For creating breakpoint on address \lstinline{0x02}, the debugger needs to replace code on that location with the \lstinline{0xCC}. The result would look like this 

\begin{lstlisting}
    0x0 xor    eax,eax        33 c0
    0x2 int3                  cc e5
    0x4 pop    ebp            5d
\end{lstlisting}.

The processor executes the \lstinline{xor}, then the \lstinline{int3}, this sends the interrupt, but because that instruction was executed the program counter is now set to \lstinline{0x3}. If the debugger would just told the program to continue it would execute the instruction at that point, which begins with \lstinline{0xe5}. If the replaced instruction is one byte in size, it would skip the replaced instruction and execute the rest of the program. If it was bigger, it would essentially interpret the body of that instruction as new instruction. This would most likely cause a crash. The debugger needs to deal with this. But first, lets see how different operating system allows debugging via their api.

\subsection{ptrace}
Linux offers special system call which is very handy for debugging. It is called \lstinline{ptrace} \cite{ptrace} - process trace. It has following signature: \lstinline{ptrace(PTRACE_COMMAND, pid, ...)}. It takes a \lstinline{PTRACE_COMMAND}, which specifies the behaviour of the function (for example \lstinline{PTRACE_SINGLESTEP} for single step), pid of some process and some other parameters, depending on the \lstinline{PTRACE_COMMAND}. 

It allows to observe and control the execution of another process, which will most often be the debuggee. When the debugee is traced, it will stop each time a signal is delivered\footnote{\lstinline{SIGKILL} is an exception, it will have its usual effect.}. The debugger will be notified at its next call to \lstinline{waitpid}. This system call return value will indicate the reason debuggee stopped. \lstinline{ptrace(PTRACE_TRACEME, ...)} called from a child of the debugger will cause the debugger to \textit{attach} to the child, which is the debuggee. The debugger can then issue other commands to the child. There are also \lstinline{PTRACE_ATTACH} and \lstinline{PTRACE_SEIZE}, which can be used for attaching to existing process.

\lstinline{ptrace} has many commands, here are some of the most important:
\begin{itemize}
    \item \lstinline{PTRACE_PEEKTEXT, PTRACE_PEEKDATA} - Read tracee's memory,
    \item \lstinline{PTRACE_POKETEXT, PTRACE_POKEDATA} - Write into tracee's memory,
    \item \lstinline{PTRACE_GETREGS} - Read tracee's register values,
    \item \lstinline{PTRACE_SETREGSET} - Modify tracee's register values,
    \item \lstinline{PTRACE_GETSIGINFO} - Retrieve information about the signal that caused tracee to stop,
    \item \lstinline{PTRACE_CONT} - Restart the stopped tracee process,
    \item \lstinline{PTRACE_SINGLESTEP} - Restart the stopped tracee but stop it after executing one instruction.
\end{itemize}

\todo{Describe how they are used in real code}

\subsection{Windows}
Windows also has built in support for debugging at the Win32API layer \cite{windows-msdn-debugging-api, windows-press-debugging-api}. It builds on \textit{debug events} and two \textit{debug functions} and it allows to write into the virtual address space of another process, which is needed for debugging. Win32 API offers following functions which all help with debugging:

\begin{itemize}
    \item \lstinline{CreateProcess} - Start a target process under control of a debugger
    \item \lstinline{OpenProcess} - Attach to an existing process
    \item \lstinline{DebugActiveProcessStop} - Stop debugging the process without terminating it
    \item \lstinline{DebugBreakProcess} - Causes a breakpoint exception to occur in the specified process. This passes control of the process to the debugger, if there is one.
    \item \lstinline{WaitForDebugEvent} - Waits for new debug events
    \item \lstinline{ContinueDebugEvent} - Continue the debuggee execution after processing debug event
    \item \lstinline{ReadProcessMemory} and \lstinline{WriteProcessMemory} - Read and modify debuggee virtual address space.
\end{itemize}

The general structure of Windows debugger can be seen in figure \ref{fig:win32debugger}.

\begin{figure}
    \centering
    \scalebox{0.8}{
    \begin{tikzpicture}
        \draw (-7,0) -- (-7,-11) (0,0) -- (0,-11) (7,0) -- (7,-11);
        \node at (-7,.3) {Debugee};
        \node at (0,.3) {Win32 API};
        \node at (7,.3) {Debugger};
        \draw[<-] (0,-1) -- node[midway,above] {\texttt{CreateProcess}} (7,-1);
        \draw[<-] (-7,-2) -- node[midway,above] {Create} (0,-2);
        \draw[->] (0,-3) -- node[midway,above] {\texttt{CreateProcess} returns} (7,-3);
        \draw[<-] (0,-5) -- node[midway,above] {\texttt{ContinueDebugProcess}} (7,-5);
        \draw[<-] (0,-6) -- node[midway,above] {\texttt{WaitForDebugEvent}} (7,-6);
        \draw[dashed,->] (-7,-6.5) -- node[midway,above] {Exception} (0,-6.5);
        \draw[->] (0,-7) -- node[midway,above] {\texttt{WaitForDebugEvent} returns \texttt{true}} (7,-7);
        \draw[dashed, <-] (-7, -8) -- node[above left] {Debugger actions} (7, -8);
        \draw[<-] (0,-9) -- node[midway,above] {\texttt{ContinueDebugProcess}} (7,-9);
        \draw[<-] (0,-10) -- node[midway,above] {\texttt{WaitForDebugEvent}} (7,-10);
        \draw[dashed,->] (-7,-10.5) -- node[midway,above] {Exception} (0,-10.5);
    \end{tikzpicture}
    }
    \caption{A caption}
    \label{fig:win32debugger}
\end{figure}

\begin{lstlisting}

\end{lstlisting}

\subsubsection*{Debug Events}

